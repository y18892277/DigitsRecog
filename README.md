# 图片手写数字识别器 (支持多数字)

本项目提供一个基于Python、Tkinter、OpenCV和TensorFlow/Keras的图形用户界面（GUI）应用程序，允许用户上传包含手写数字的图片，程序将尝试识别图片中的一个或多个数字，并在界面上显示结果。

## 核心组件

*   `model.h5`: 预先训练好的手写数字识别模型（基于Keras）。这是程序进行数字预测的核心。**必须与 `image_uploader_recognizer.py` 存放在同一目录下。**
*   `image_uploader_recognizer.py`: 主应用程序脚本。它提供了GUI，处理用户上传的图片，执行一系列图像预处理步骤，然后调用加载的 `model.h5` 模型进行数字识别。
*   `debug_images/` (文件夹): 程序运行时，会将各个预处理阶段的中间图像保存到此文件夹中，方便调试和理解图像处理流程。如果此文件夹不存在，程序会自动创建它。

## 如何运行

1.  **环境准备**:
    确保你的Python环境中安装了以下必要的库：
    *   `tensorflow` (或 `tensorflow-cpu`，用于加载和运行Keras模型)
    *   `opencv-python` (即 `cv2`，用于图像处理)
    *   `Pillow` (PIL Fork，用于图像文件操作和Tkinter图像显示)
    *   `numpy` (通常作为其他库的依赖自动安装)

    你可以使用pip进行安装：
    ```bash
    pip install tensorflow opencv-python Pillow numpy
    ```

2.  **文件放置**:
    将 `model.h5` 模型文件与 `image_uploader_recognizer.py` 脚本放在同一个文件夹内。

3.  **运行程序**:
    在终端中，导航到包含上述文件的目录，然后执行：
    ```bash
    python image_uploader_recognizer.py
    ```
    程序启动后，会显示一个图形界面。

## 主要功能

*   **图片上传**: 用户可以通过"上传图片并识别"按钮选择本地的图片文件（支持常见格式如 PNG, JPG, BMP 等）。
*   **多数字识别**: 程序能够识别一张图片中从左到右排列的多个数字。
*   **界面预览**:
    *   **左侧**: 显示用户上传的原始图片（会缩放到适合预览的大小）。
    *   **右侧上方**: 显示经过一系列预处理后，用于提取候选数字的图像（步骤M5e的输出），并在该图像上用绿色框标出所有被识别为候选数字的区域及其从左到右的索引。
    *   **右侧下方**: 显示最终识别出的数字序列。

## 图像预处理与多数字识别详细流程

程序在识别数字前，会对上传的图片进行一系列复杂的预处理操作。这些步骤对于提高识别准确率至关重要。以下是主要的流程和在 `debug_images` 文件夹中对应的文件名约定（`bX` 代表自适应阈值的`blockSize`，`cX` 代表`C_val`，`kX` 代表形态学核大小，`TX` 代表面积阈值，`digitN` 代表第N个候选数字）：

### A. 公共预处理阶段 (输入: 原始图片 -> 输出: `image_for_noise_filtering`)

1.  `0_original_uploaded_pil.png`: 用户通过文件对话框选择并由Pillow库初步加载的原始图像。
2.  `0a_original_opencv_bgr.png`: 将Pillow图像转换为OpenCV的BGR格式。
3.  `1_prescaled_cv.png`: 如果原始图像尺寸过大（任一边大于400像素），则按比例将其缩小，以加快后续处理速度。
4.  `2_gray_cv.png`: 将预缩放后的彩色图像转换为灰度图像。
5.  `3_blurred_cv_k3_for_adaptive.png`: 对灰度图像应用(3x3)核的高斯模糊，以平滑图像，为后续的自适应阈值化做准备。
6.  `4_adaptive_gaussian_inv_bX_cX_HDBZ.png`: 对模糊图像进行自适应阈值二值化（高斯方法，反转阈值 `THRESH_BINARY_INV`），使得数字呈白色，背景呈黑色。`bX`和`cX`是此步骤的参数。
7.  `4b_white_noise_filtered_TX_after_4.png` (或 `..._no_change.png`): **(新增)** 对步骤4的输出进行连通区域分析，移除面积小于特定阈值 `TX` (默认为5) 的微小白色噪点区域。
8.  `5a_morph_close_bX_cX_k3.png`: (原步骤7) 对步骤4b（或步骤4，如果4b无改动）的输出应用(3x3)核的形态学**闭运算**。目的是填充数字内部的小孔洞，连接断裂的笔画。
9.  `5b_opened_after_close_bX_cX_k2.png`: (原步骤8) 紧接着对上一步闭运算的结果应用(2x2)核的形态学**开运算**。
10. `5c_contour_filtered_bX_cX_k2_TX.png`: (原步骤9) 对上一步开运算的结果，通过轮廓分析进行精细去噪。移除面积小于 `max_noise_area_threshold` (当前为20) 的白色噪点。
    *   **到此步骤为止的输出 (`image_for_noise_filtering`) 是后续多数字识别流程的起点。**

### B. 多数字识别阶段 (输入: `image_for_noise_filtering` from 步骤5c - 现为步骤10)

1.  **寻找候选轮廓**: 在 `image_for_noise_filtering` (步骤10的输出) 上查找所有外部轮廓 (`cv2.RETR_EXTERNAL`)。
2.  **筛选与排序**:
    *   使用 `min_digit_area` (当前代码中为25像素) 过滤掉面积过小的轮廓。
    *   将通过筛选的候选轮廓按照其边界框的X坐标从左到右排序。
3.  `M5e_candidate_digits_on_5c_bX_cX_k2_TX.png`: **(UI预览图)** (文件名中的5c现在代表源自原5c逻辑，即步骤10的输出) 创建 `image_for_noise_filtering` 的一个彩色副本，并在上面用绿色矩形框标记出所有筛选并排序后的候选数字轮廓，同时标注它们的索引号（从0开始）。这张图像会显示在GUI的右上方预览区域。
4.  **循环处理每个候选数字**: 对于列表中的每一个候选数字轮廓 (`contour_item`，索引为 `digitN`)，独立执行以下子处理流程 (基于步骤10的输出 `image_for_noise_filtering`)：
    *   `final_mnist_like_image_np`: 为当前数字创建一个新的空白28x28 NumPy数组（黑色背景）。
    *   `M6_cropped_roi_digitN_bX_cX_TX.png`: **(裁剪)** 从 `image_for_noise_filtering` (步骤10的输出)中裁剪ROI。
    *   `M7_scaled_roi_digitN_INTER_AREA_thresh127_TX.png`: **(缩放与二值化)** 
        1.  将步骤M6裁剪出的ROI (`cleaned_digit_roi_cv`) 使用 `cv2.INTER_AREA` 插值方法缩放到适合放置在28x28画布内部的尺寸（通常是20x20左右，四周留白 `padding=4`）。`cv2.INTER_AREA` 在缩小时能较好地保留线条信息，但可能产生灰度值。
        2.  对缩放后的图像进行阈值处理 (`cv2.threshold`，阈值127)，将其重新转换为清晰的二值图像（黑白）。
    *   `M9_final_for_model_digitN_TX.png`: **(最终模型输入准备)** 将步骤M7处理后的二值化 `scaled_digit_roi_cv` 放置到之前创建的28x28黑色背景 `final_mnist_like_image_np` 的中央。像素值归一化到0-1范围。
    *   **预测**: 将这个28x28的 `final_mnist_like_image_np` 数组调整形状后送入加载的 `model.h5` 模型进行预测，得到该候选数字的识别结果。
5.  **结果汇总**: 将所有独立识别出的数字（字符串形式）按顺序连接起来，形成最终的识别序列，显示在GUI右下方的结果区域。

## 调试图像说明

所有在预处理和识别过程中产生的中间图像都会保存在程序目录下的 `debug_images` 文件夹中。文件名通常会包含关键步骤的标识和参数值，方便用户理解每一步操作的效果。前缀 `M` 通常表示这是多数字识别流程中的一个步骤。

## 可配置参数与注意事项

在 `image_uploader_recognizer.py` 脚本中，有一些参数可能会影响识别效果，高级用户可以尝试调整它们：

*   **`IMAGE_DISPLAY_SIZE` (默认 280)**: GUI中原始图片预览区域的大小。
*   **`IMAGE_SIZE` (默认 28)**: MNIST模型的标准输入图像尺寸。
*   **自适应阈值参数 (`blockSize`, `C_val` in `cv2.adaptiveThreshold`)**: 这些参数影响步骤4的二值化效果。
    *   `blockSize` (默认 11): 计算阈值时考虑的邻域大小。
    *   `C_val` (默认 2): 从均值或加权均值中减去的常数。
*   **形态学操作核大小**:
    *   步骤5a (闭运算): 默认 (3,3) (现在是流程中的步骤8)
    *   步骤5b (开运算): 默认 (2,2) (现在是流程中的步骤9)
    *   **`kernel_size_morph_close_after_adaptive_thresh` (元组, 默认: `(3,3)`)**: 步骤5a中闭运算的核大小。
    *   **`kernel_size_morph_open_after_close` (元组, 默认: `(2,2)`)**: 步骤5b中开运算的核大小。
*   **`max_white_noise_area_after_4` (步骤4b新增的面积阈值，默认 5)**: 用于移除自适应阈值化后（步骤4）的微小白色噪点。如果设得太高，可能会损伤数字的细小部分。
*   **`max_noise_area_threshold` (步骤5c的面积阈值，默认 20)**: (现在是流程中的步骤10) 用于移除在形态学操作后（步骤9）仍然存在的噪点轮廓。
*   **`min_digit_area` (多数字识别中候选轮廓的最小面积，默认 25)**: 用于筛选有效的数字轮廓。如果数字本身很小或者预处理后变得很小，可能需要降低此值。
*   **`padding_for_model_input` (整数, 默认: `4`)**: 在将缩放后的ROI（步骤M7）粘贴到28x28图像（步骤M8）时，内容区域周围的黑色边框宽度。

**重要注意事项**:

*   **粘连数字**: 当前的多数字识别逻辑基于轮廓查找。如果图片中的数字紧密粘连（例如 "00" 看起来像一个整体，或 "17" 的 "1" 和 "7" 接触紧密），它们很可能被识别为一个单独的轮廓，从而导致识别错误或只识别出部分。解决此问题需要更高级的图像分割技术，超出了当前项目的范围。
*   **数字质量与书写**: 识别效果高度依赖于输入图片中数字的清晰度、完整性以及书写方式是否与模型训练数据（MNIST）相似。过于潦草、断裂严重或风格特异的数字可能难以正确识别。
*   **参数调整**: 如果对某些特定类型的图片识别效果不佳，可以尝试调整上述参数，特别是形态学操作的核大小、面积阈值等。

## 未来可能的改进方向

1.  **参数动态调整**: 允许用户通过GUI界面动态调整一些关键的预处理参数（如面积阈值、形态学核大小），而不是直接修改代码。
2.  **高级分割算法**: 研究并引入更鲁棒的数字分割算法，以更好地处理粘连数字的情况。
3.  **模型优化/替换**: 使用更先进的模型结构或更大的数据集重新训练模型，以提高识别准确率和泛化能力。
4.  **用户反馈机制**: 允许用户标记识别错误的结果，收集数据用于未来模型改进。
5.  **界面美化与UX**: 使用更现代的GUI框架或对现有Tkinter界面进行美化，提升用户体验。

---
希望这个手写数字识别器能帮助你！ 